{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"feed-io","text":"<p>feed-io is a PHP library built to consume and serve RSS / Atom feeds.</p> <pre><code>&lt;?php\nrequire 'vendor/autoload.php';\n\nuse \\FeedIo\\Factory;\n\n$feedIo = Factory::create()-&gt;getFeedIo();\n$result = $feedIo-&gt;read('http://php.net/feed.atom');\n\necho \"feed title : {$result-&gt;getFeed()-&gt;getTitle()} \\n\";\nforeach ($result-&gt;getFeed() as $item) {\n    echo \"{$item-&gt;getLastModified()-&gt;format(\\DateTime::ATOM)} : {$item-&gt;getTitle()} \\n\";\n    echo \"{$item-&gt;getDescription()} \\n\";\n}\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Use Composer to add feed-io into your project's requirements :</p> <pre><code>composer require php-feed-io/feed-io\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"feed-io PHP 5.0 8.0+ 6.0 8.1+"},{"location":"#usage","title":"Usage","text":""},{"location":"#cli","title":"CLI","text":"<p>Let's suppose you installed feed-io using Composer, you can use its command line client to read feeds from your terminal :</p> <pre><code>./vendor/bin/feedio read http://php.net/feed.atom\n</code></pre> <p>You can specify the number of items you want to read using the --count option. The instruction below will display the latest item :</p> <pre><code>./vendor/bin/feedio read -c 1 http://php.net/feed.atom\n</code></pre>"},{"location":"#reading","title":"Reading","text":"<p>feed-io is designed to read feeds across the internet and to publish your own. Its main class is FeedIo :</p> <pre><code>&lt;?php\n// create a simple FeedIo instance\n$feedIo = \\FeedIo\\Factory::create()-&gt;getFeedIo();\n\n// read a feed\n$result = $feedIo-&gt;read($url);\n\n// get title\n$feedTitle = $result-&gt;getFeed()-&gt;getTitle();\n\n// iterate through items\nforeach( $result-&gt;getFeed() as $item ) {\n    echo $item-&gt;getTitle();\n}\n</code></pre>"},{"location":"#next-update-estimation","title":"Next Update estimation","text":"<p>In order to save bandwidth, feed-io estimates the next time it will be relevant to read the feed and get new items from it.</p> <pre><code>&lt;?php\n$nextUpdate = $result-&gt;getNextUpdate();\necho \"computed next update: {$nextUpdate-&gt;format(\\DATE_ATOM)}\";\n\n// you may need to access the statistics\n$updateStats = $result-&gt;getUpdateStats();\necho \"average interval in seconds: {$updateStats-&gt;getAverageInterval()}\";\n</code></pre> <p>feed-io calculates the next update time by first detecting if the feed was active in the last 7 days and if not we consider it as sleepy. The next update date for a sleepy feed is set to the next day at the same time. If the feed isn't sleepy we use the average interval and the median interval by adding those intervals to the feed's last modified date and compare the result to the current time. If the result is in the future, then it's returned as the next update time. If none of them are in the future, we considered the feed will be updated quite soon, so the next update time is one hour later from the moment of the calculation. Please note: the fixed delays for sleepy and closed to be updated feeds can be set through Result::getNextUpdate() arguments, see Result for more details.</p>"},{"location":"#formatting-an-object-into-a-xml-stream","title":"Formatting an object into a XML stream","text":"<pre><code>&lt;?php\n// build the feed\n$feed = new FeedIo\\Feed;\n$feed-&gt;setTitle('...');\n\n// convert it into Atom\n$atomString = $feedIo-&gt;toAtom($feed);\n\n// or ...\n$atomString = $feedIo-&gt;format($feed, 'atom');\n</code></pre>"},{"location":"#building-a-feed-including-medias","title":"Building a feed including medias","text":"<pre><code>// build the feed\n$feed = new FeedIo\\Feed;\n$feed-&gt;setTitle('...');\n\n$item = $feed-&gt;newItem();\n\n// build the media\n$media = new \\FeedIo\\Feed\\Item\\Media\n$media-&gt;setUrl('http://yourdomain.tld/medias/some-podcast.mp3');\n$media-&gt;setType('audio/mpeg');\n\n// add it to the item\n$item-&gt;addMedia($media);\n\n$feed-&gt;add($item);\n</code></pre>"},{"location":"#activate-logging","title":"Activate logging","text":"<p>feed-io natively supports PSR-3 logging, you can activate it by choosing a 'builder' in the factory :</p> <pre><code>$feedIo = \\FeedIo\\Factory::create(['builder' =&gt; 'monolog'])-&gt;getFeedIo();\n</code></pre> <p>feed-io only provides a builder to create Monolog\\Logger instances. You can write your own, as long as the Builder implements BuilderInterface. Building a FeedIo instance without the factory</p> <p>To create a new FeedIo instance you only need to inject two dependencies :</p> <ul> <li>an HTTP Client implementing FeedIo\\Adapter\\ClientInterface. It can be wrapper for an external library like FeedIo\\Adapter\\Guzzle\\Client</li> <li>a PSR-3 logger implementing Psr\\Log\\LoggerInterface</li> </ul> <pre><code>// first dependency : the HTTP client\n// here we use Guzzle as a dependency for the client\n$guzzle = new GuzzleHttp\\Client();\n// Guzzle is wrapped in this adapter which is a FeedIo\\Adapter\\ClientInterface  implementation\n$client = new FeedIo\\Adapter\\Guzzle\\Client($guzzle);\n\n// second dependency : a PSR-3 logger\n$logger = new Psr\\Log\\NullLogger();\n\n// now create FeedIo's instance\n$feedIo = new FeedIo\\FeedIo($client, $logger);\n</code></pre>"},{"location":"codecontributions/","title":"Code Quality","text":"<p>This project uses PHPStan for static analysis and Rector for automated code refactoring to maintain high code quality standards.</p>"},{"location":"codecontributions/#phpstan-static-analysis","title":"PHPStan - Static Analysis","text":"<p>PHPStan analyzes the code for potential issues and type safety problems. The configuration is stored in <code>phpstan.neon.dist</code>.</p>"},{"location":"codecontributions/#generate-a-new-baseline","title":"Generate a new baseline","text":"<p>When introducing PHPStan to legacy code or after major refactoring, you can create a baseline to suppress existing errors: <pre><code>vendor/bin/phpstan analyse --generate-baseline\n</code></pre></p>"},{"location":"codecontributions/#run-analysis","title":"Run analysis","text":"<p>To analyze the codebase and find issues: <pre><code>vendor/bin/phpstan analyse\n</code></pre></p>"},{"location":"codecontributions/#configuration","title":"Configuration","text":"<ul> <li>Configuration file: <code>phpstan.neon.dist</code></li> <li>Current analysis level: 5</li> <li>Baseline file: <code>phpstan-baseline.neon</code> (suppresses known issues)</li> </ul>"},{"location":"codecontributions/#rector-automated-refactoring","title":"Rector - Automated Refactoring","text":"<p>Rector automatically modernizes PHP code and applies coding standards. The configuration is stored in <code>rector.php</code>.</p>"},{"location":"codecontributions/#preview-changes-recommended-first-step","title":"Preview changes (recommended first step)","text":"<p>Run a dry-run to see what changes Rector would make without actually modifying files: <pre><code>vendor/bin/rector process --dry-run\n</code></pre></p>"},{"location":"codecontributions/#apply-changes","title":"Apply changes","text":"<p>Apply the refactoring rules to actually modify the code: <pre><code>vendor/bin/rector process\n</code></pre></p>"},{"location":"codecontributions/#debug-mode","title":"Debug mode","text":"<p>To see detailed information about what Rector is doing: <pre><code>vendor/bin/rector process --dry-run --debug\n</code></pre></p>"},{"location":"codecontributions/#finding-new-rules","title":"Finding new rules","text":"<p>To discover additional Rector rules for your project, visit: https://getrector.com/find-rule</p>"},{"location":"codecontributions/#workflow","title":"Workflow","text":"<ol> <li>Before making changes: Run <code>vendor/bin/phpstan analyse</code> to check current code quality</li> <li>Use Rector for improvements: Run <code>vendor/bin/rector process --dry-run</code> to preview automated fixes</li> <li>Apply safe changes: Run <code>vendor/bin/rector process</code> to apply the changes</li> <li>Verify with tests: Run <code>make test</code> to ensure changes don't break functionality</li> <li>Final analysis: Run <code>vendor/bin/phpstan analyse</code> to confirm improvements</li> </ol>"},{"location":"codecontributions/#cicd-integration","title":"CI/CD Integration","text":"<p>Both PHPStan and Rector are integrated into the CI pipeline to ensure: - No new PHPStan errors are introduced (beyond the baseline) - Code follows modern PHP practices through Rector</p>"},{"location":"specifications-support/","title":"synopsis","text":"<p>This document explains which attributes are supported by feed-io and how to access them</p>"},{"location":"specifications-support/#top-level-document-feed-atom-channel-rss-top-level-json","title":"top level document : feed (atom) / channel (rss) / top-level (json)","text":"<p>interface : FeedInterface</p> atom rss json getter setter title title title getTitle setTitle link link home_page_url getLink setLink link (rel=self) N/A feed_url getLink setLink updated pubDate / lastBuildDate N/A getLastModified setLastModified id N/A N/A getPublicId setPublicId description description description getDescription setDescription category category N/A getCategories addCategory author author author(s) getAuthor setAuthor contributor N/A N/A not supported not supported logo image icon getLogo setLogo rights copyright N/A not supported not supported subtitle N/A N/A not supported not supported lang language N/A getLanguage setLanguage base N/A N/A not supported not supported generator generator N/A not supported not supported N/A managingEditor N/A not supported not supported N/A webMaster N/A not supported not supported N/A docs N/A not supported not supported N/A cloud hubs not supported not supported N/A ttl N/A not supported not supported N/A rating N/A not supported not supported N/A textInput N/A not supported not supported N/A skipdays N/A not supported not supported N/A skipHours N/A not supported not supported N/A N/A expired not supported not supported"},{"location":"specifications-support/#entry-atom-item-rss-item-json","title":"entry (atom) / item (rss) / item (json)","text":"<p>Interface : ItemInterface</p> atom rss json getter setter title title title getTitle setTitle link link url getLink setLink link enclosure image (get only) getMedias addMedia updated / published pubDate date_published getLastModified setLastModified id guid id getPublicId setPublicId content description content_html / content_text getContent setContent summary N/A summary getSummary setSummary source source N/A not supported not supported category category tags (wip) getCategories addCategory author N/A author getAuthor setAuthor contributor N/A N/A not supported not supported N/A comments N/A not supported not supported rights N/A N/A not supported not supported N/A N/A external_url not supported not supported N/A N/A banner_image not supported not supported N/A N/A attachments not supported not supported N/A N/A date_modified not supported not supported"},{"location":"upgrades/UPGRADE-3.0/","title":"UPGRADE FROM 2.x to 3.0","text":""},{"location":"upgrades/UPGRADE-3.0/#feedioformat-now-returns-a-string","title":"FeedIo::format() now returns a string","text":"<p>In version 2.x FeedIo::format() returned a DomDocument. Now that feed-io supports JSON Feed, this is no longer relevant so now FeedIo::format() returns a string</p> <p>Before :</p> <pre><code>&lt;?php\n\n// Feed creation\n$feed = new \\FeedIo\\Feed();\n\n// set all feed properties and add items ...\n$feed-&gt;setTitle('your title');\n\n// ...\n\n\n$feedIo = \\FeedIo\\Factory::create()-&gt;getFeedIo();\n\n$domDocument = $feedIo-&gt;format($feed, 'atom');\necho $domDocument-&gt;saveXML();\n</code></pre> <p>Now you get the string :</p> <pre><code>&lt;?php\n\n// Feed creation\n$feed = new \\FeedIo\\Feed();\n\n$feedIo = \\FeedIo\\Factory::create()-&gt;getFeedIo();\n\necho $feedIo-&gt;format($feed, 'atom');\n</code></pre>"},{"location":"upgrades/UPGRADE-3.0/#resultgetdocument-returns-a-feedioreaderdocument-instance","title":"Result::getDocument() returns a \\FeedIo\\Reader\\Document instance","text":"<p>Instead of a DomDocument.</p> <p>Before :</p> <pre><code>&lt;?php\n\n$feedIo = \\FeedIo\\Factory::create()-&gt;getFeedIo();\n\n$result = $feedIo-&gt;read('http://php.net/feed.atom');\n\n$dom = $result-&gt;getDocument();\n</code></pre> <p>After :</p> <pre><code>&lt;?php\n\n$feedIo = \\FeedIo\\Factory::create()-&gt;getFeedIo();\n\n$result = $feedIo-&gt;read('http://php.net/feed.atom');\n\n$dom = $result-&gt;getDocument()-&gt;getDOMDocument();\n</code></pre> <p>This is because <code>Result::getDocument()</code>'s return value is a wrapper for both XML and JSON streams.</p>"},{"location":"upgrades/UPGRADE-3.0/#thats-it","title":"That's it","text":"<p>There are no other modifications to upgrade into 3.0.</p>"},{"location":"upgrades/UPGRADE-4.0/","title":"UPGRADE FROM 3.x to 4.0","text":"<p>The major change in version 4.0 is the full migration to PHP 7.1. It has an impact on interface implementations.</p>"},{"location":"upgrades/UPGRADE-4.0/#types-are-explicit","title":"Types are explicit","text":"<p>From now on, all types are explicits in method signatures. It has an impact on classes that implements :</p> <ul> <li><code>\\FeedIo\\FeedInterface</code></li> <li><code>\\FeedIo\\Feed\\ItemInterface</code></li> <li><code>\\FeedIo\\Feed\\NodeInterface</code></li> <li><code>\\FeedIo\\Feed\\ElementsAwareInterface</code></li> <li><code>\\FeedIo\\Feed\\Item\\AuthorInterface</code></li> <li><code>\\FeedIo\\Feed\\Item\\MediaInterface</code></li> <li><code>\\FeedIo\\Feed\\Node\\CategoryInterface</code></li> <li><code>\\FeedIo\\Feed\\Node\\ElementInterface</code></li> </ul> <p>For instance, <code>FeedIo\\FeedInterface::setUrl($url)</code> becomes :</p> <p><pre><code>&lt;?php\n\n    /**\n     * @param string $url\n     * @return FeedInterface\n     */\n    public function setUrl(string $url) : FeedInterface;\n</code></pre> As a consequence, you need to adapt any class that implements <code>FeedIo\\FeedInterface</code> according to the new signature : </p> <p><pre><code>&lt;?php\n\n    /**\n     * @param string $url\n     * @return FeedInterface\n     */\n    public function setUrl($url)\n    {\n        $this-&gt;url = $url;\n\n        return $this;\n    }\n</code></pre> becomes : </p> <p><pre><code>&lt;?php\n\n    /**\n     * @param string $url\n     * @return FeedInterface\n     */\n    public function setUrl(string $url) : FeedInterface\n    {\n        $this-&gt;url = $url;\n\n        return $this;\n    } \n</code></pre> You should refer to the new interfaces declaration to get the full list of concerned functions.</p>"},{"location":"upgrades/UPGRADE-5.0/","title":"UPGRADE FROM 4.x to 5.0","text":"<p>Several major changes in version 5.0:  - Full migration to PHP 8.0  - <code>readSince()</code> has been removed alongside with the <code>FilterInterface</code>  - <code>readAsync()</code> has been removed  - <code>description</code> is an attribute of the feed, whereas the item contains <code>summary</code> and <code>content</code></p>"},{"location":"upgrades/UPGRADE-5.0/#readsince-removal","title":"readSince() removal","text":"<p>Despite how convenient <code>readSince()</code> can be, it doesn't work in every case. It's because some feeds doesn't include the publication date for each item, making impossible to filter the outdated ones and keep only the fresh material. As a consequence, the client application is forced to check the item's existence in its database exactly like it would do without the date filtering. That makes <code>readSince()</code> pointless, so it's better to remove it.</p> <p>The <code>FilterInterface</code> is also removed as it's not used for any other matter.</p>"},{"location":"upgrades/UPGRADE-5.0/#readasync-removal","title":"readAsync() removal","text":"<p>It's a complicated piece of code, complex to use and that could be easily replaced with another architecture to perform concurrent reads. It's not worth keeping it, so the best choice is to stick with the most used reading method.</p>"},{"location":"upgrades/UPGRADE-5.0/#description-content-naming-change","title":"<code>description</code> / <code>content</code> naming change","text":"<p>get/setDescription is now at the Feed's level, items expose get/setSummary and get/setContent.</p>"},{"location":"upgrades/UPGRADE-5.0/#no-more-complaining-about-malformed-date","title":"No more complaining about malformed date","text":"<p>When a feed-io is malformed, feed-io won't throw an exception anymore. It will return current date instead</p>"},{"location":"upgrades/UPGRADE-6.0/","title":"UPGRADE FROM 5.x to 6.0","text":"<p>Several major changes in version 6.0:  - Requires PHP 8.1  - The factory has been removed. Use <code>new</code> to construct your FeedIO instance: <code>new \\FeedIo\\FeedIo($client, $logger)</code>  - Feed IO comes no longer bundled with a default HTTP client, but uses HTTPlug instead. To continue using Guzzle, please require <code>php-http/guzzle7-adapter</code>.  - Feed IO does no longer set a custom user agent. However, HTTP clients usually add a default themselves. If the feed you want to read requires a specific user agent, please configure your HTTP client accordingly, before you inject it into Feed IO. </p>"}]}